name: Deploy to VPS

on:
  push:
    branches:
      - "**"
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to deploy"
        required: true
        default: "main"
      full_setup:
        description: "Force full setup (Docker, Nginx, SSL)"
        type: boolean
        default: false
      force_rebuild:
        description: "Force docker build --no-cache"
        type: boolean
        default: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # Continue deploying to other VPS even if one fails
      matrix:
        environment: [CC, DMIT, ORACLE, RACKNERD]  # Add/remove VPS environments as needed
    environment: ${{ matrix.environment }}
    name: Deploy to ${{ matrix.environment }}
    env:
      DEPLOY_BRANCH: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.branch || github.ref_name }}
    steps:
      - name: Check if deployment is enabled
        id: check_enabled
        run: |
          if [ "${{ secrets.DEPLOY_ENABLED }}" != "true" ]; then
            echo "‚è≠Ô∏è Deployment to ${{ matrix.environment }} is disabled (DEPLOY_ENABLED != true)"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Deployment to ${{ matrix.environment }} is enabled"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi
      - name: Checkout code
        if: steps.check_enabled.outputs.skip != 'true'
        uses: actions/checkout@v4

      - name: Check if incremental deploy
        id: check_incremental
        if: steps.check_enabled.outputs.skip != 'true'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          debug: true
          script: |
            whoami
            # Check if first-time setup is needed
            if [ "${{ github.event.inputs.full_setup }}" = "true" ]; then
              echo "üîÑ Force full setup requested"
              echo "needs_setup=true" >> /tmp/deploy_flags
            elif [ ! -f /opt/qubot/.deployed ]; then
              echo "üÜï First-time deployment detected"
              echo "needs_setup=true" >> /tmp/deploy_flags
            else
              echo "‚ö° Incremental deployment (skipping setup)"
              echo "needs_setup=false" >> /tmp/deploy_flags
            fi

            # Check if Docker is available (not Podman shim, daemon reachable)
            needs_docker=false
            if ! command -v docker &> /dev/null; then
              needs_docker=true
            elif docker --version 2>/dev/null | grep -qi podman; then
              needs_docker=true
            elif ! docker info &> /dev/null; then
              needs_docker=true
            fi

            if [ "$needs_docker" = "true" ]; then
              echo "üê≥ Docker not available, will install/start"
            else
              echo "üê≥ Docker available"
            fi
            echo "needs_docker=$needs_docker" >> /tmp/deploy_flags
            
            # Output the flag
            cat /tmp/deploy_flags

      - name: Get deploy flags
        id: flags
        if: steps.check_enabled.outputs.skip != 'true'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            cat /tmp/deploy_flags 2>/dev/null || echo "needs_setup=true"

      - name: Install Docker if needed
        if: steps.check_enabled.outputs.skip != 'true' && (contains(steps.flags.outputs.stdout, 'needs_setup=true') || contains(steps.flags.outputs.stdout, 'needs_docker=true') || github.event.inputs.full_setup == 'true')
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            SUDO=""
            if [ "$(id -u)" != "0" ]; then
              SUDO="sudo"
            fi
            
            # Install Git
            if ! command -v git &> /dev/null; then
              echo "üì¶ Installing Git..."
              $SUDO apt-get update
              $SUDO apt-get install -y git
            fi
            
            # Install Docker (treat Podman shim or missing CLI as no-Docker)
            docker_cmd_missing=false
            docker_is_podman=false
            docker_daemon_ok=true
            if ! command -v docker &> /dev/null; then
              docker_cmd_missing=true
            elif docker --version 2>/dev/null | grep -qi podman; then
              docker_is_podman=true
            elif ! docker info &> /dev/null; then
              docker_daemon_ok=false
            fi

            if [ "$docker_cmd_missing" = "true" ] || [ "$docker_is_podman" = "true" ]; then
              echo "üê≥ Installing Docker..."
              curl -fsSL https://get.docker.com | sh
              $SUDO usermod -aG docker $USER || true
            elif [ "$docker_daemon_ok" = "false" ]; then
              echo "üê≥ Docker installed but daemon not running; will start service"
            fi
            
            # Install Docker Compose
            if ! docker compose version &> /dev/null; then
              $SUDO apt-get update
              $SUDO apt-get install -y docker-compose-plugin
            fi
            
            # Start Docker
            $SUDO systemctl daemon-reload 2>/dev/null || true
            $SUDO systemctl enable --now docker.socket 2>/dev/null || true
            $SUDO systemctl restart docker 2>/dev/null || true
            $SUDO systemctl enable docker 2>/dev/null || true

            # Wait for Docker socket to become available
            for i in 1 2 3 4 5; do
              if [ -S /run/docker.sock ] && docker info &> /dev/null; then
                break
              fi
              sleep 2
            done
            
            # Configure firewall
            if command -v ufw &> /dev/null; then
              $SUDO ufw allow ssh
              $SUDO ufw allow 80/tcp
              $SUDO ufw allow 443/tcp
              $SUDO ufw --force enable || true
            fi

            # Install and configure fail2ban for scanner protection
            if ! command -v fail2ban-client &> /dev/null; then
              echo "üõ°Ô∏è Installing fail2ban..."
              $SUDO apt-get install -y fail2ban
            fi

            # Create nginx scanner filter
            echo '[Definition]' | $SUDO tee /etc/fail2ban/filter.d/nginx-scanner.conf > /dev/null
            echo 'failregex = ^<HOST> .* ".*l9scan.*' | $SUDO tee -a /etc/fail2ban/filter.d/nginx-scanner.conf > /dev/null
            echo '            ^<HOST> .* "(GET|HEAD|POST) /\.(env|git|svn|htaccess|DS_Store|vscode).*' | $SUDO tee -a /etc/fail2ban/filter.d/nginx-scanner.conf > /dev/null
            echo '            ^<HOST> .* "(GET|HEAD|POST) .*(wp-admin|wp-login|phpMyAdmin|swagger|api-docs|\.php).*' | $SUDO tee -a /etc/fail2ban/filter.d/nginx-scanner.conf > /dev/null
            echo '            ^<HOST> .* ".*python-requests.*' | $SUDO tee -a /etc/fail2ban/filter.d/nginx-scanner.conf > /dev/null
            echo '            ^<HOST> .* ".*aiohttp.*' | $SUDO tee -a /etc/fail2ban/filter.d/nginx-scanner.conf > /dev/null
            echo '' | $SUDO tee -a /etc/fail2ban/filter.d/nginx-scanner.conf > /dev/null
            echo 'ignoreregex = .*Lets Encrypt.*' | $SUDO tee -a /etc/fail2ban/filter.d/nginx-scanner.conf > /dev/null
            echo '              .*well-known/acme-challenge.*' | $SUDO tee -a /etc/fail2ban/filter.d/nginx-scanner.conf > /dev/null

            # Create jail with UFW action
            echo '[nginx-scanner]' | $SUDO tee /etc/fail2ban/jail.d/nginx-scanner.conf > /dev/null
            echo 'enabled = true' | $SUDO tee -a /etc/fail2ban/jail.d/nginx-scanner.conf > /dev/null
            echo 'port = http,https' | $SUDO tee -a /etc/fail2ban/jail.d/nginx-scanner.conf > /dev/null
            echo 'filter = nginx-scanner' | $SUDO tee -a /etc/fail2ban/jail.d/nginx-scanner.conf > /dev/null
            echo 'logpath = /var/log/nginx/access.log' | $SUDO tee -a /etc/fail2ban/jail.d/nginx-scanner.conf > /dev/null
            echo 'maxretry = 2' | $SUDO tee -a /etc/fail2ban/jail.d/nginx-scanner.conf > /dev/null
            echo 'findtime = 60' | $SUDO tee -a /etc/fail2ban/jail.d/nginx-scanner.conf > /dev/null
            echo 'bantime = 604800' | $SUDO tee -a /etc/fail2ban/jail.d/nginx-scanner.conf > /dev/null
            echo 'banaction = ufw' | $SUDO tee -a /etc/fail2ban/jail.d/nginx-scanner.conf > /dev/null

            # Create SSH brute force jail (uses built-in sshd filter)
            echo '[sshd]' | $SUDO tee /etc/fail2ban/jail.d/sshd.conf > /dev/null
            echo 'enabled = true' | $SUDO tee -a /etc/fail2ban/jail.d/sshd.conf > /dev/null
            echo 'port = ssh' | $SUDO tee -a /etc/fail2ban/jail.d/sshd.conf > /dev/null
            echo 'filter = sshd' | $SUDO tee -a /etc/fail2ban/jail.d/sshd.conf > /dev/null
            echo 'logpath = /var/log/auth.log' | $SUDO tee -a /etc/fail2ban/jail.d/sshd.conf > /dev/null
            echo 'maxretry = 3' | $SUDO tee -a /etc/fail2ban/jail.d/sshd.conf > /dev/null
            echo 'findtime = 300' | $SUDO tee -a /etc/fail2ban/jail.d/sshd.conf > /dev/null
            echo 'bantime = 604800' | $SUDO tee -a /etc/fail2ban/jail.d/sshd.conf > /dev/null
            echo 'banaction = ufw' | $SUDO tee -a /etc/fail2ban/jail.d/sshd.conf > /dev/null

            # Restart fail2ban
            $SUDO systemctl enable fail2ban
            $SUDO systemctl restart fail2ban
            echo "‚úÖ fail2ban configured for scanner protection"

      - name: Setup Nginx reverse proxy
        if: steps.check_enabled.outputs.skip != 'true' && (contains(steps.flags.outputs.stdout, 'needs_setup=true') || github.event.inputs.full_setup == 'true')
        uses: appleboy/ssh-action@v1.0.3
        env:
          WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
          BOT_PORT: ${{ secrets.BOT_PORT || '6887' }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          envs: WEBHOOK_URL,BOT_PORT
          script: |
            SUDO=""
            if [ "$(id -u)" != "0" ]; then
              SUDO="sudo"
            fi
            
            # Skip if no WEBHOOK_URL
            if [ -z "$WEBHOOK_URL" ]; then
              echo "‚è≠Ô∏è WEBHOOK_URL not set, skipping Nginx setup (using polling mode)"
              exit 0
            fi
            
            # Validate BOT_PORT
            BOT_PORT=${BOT_PORT:-10001}
            if ! [[ "$BOT_PORT" =~ ^[0-9]+$ ]]; then
              echo "‚ùå Invalid BOT_PORT: $BOT_PORT, using default 10001"
              BOT_PORT=10001
            fi
            
            DOMAIN=$(echo "$WEBHOOK_URL" | sed 's|https://||' | sed 's|/.*||')
            echo "üì° Setting up Nginx for: $DOMAIN -> port $BOT_PORT"
            
            # Install Nginx
            if ! command -v nginx &> /dev/null; then
              $SUDO apt-get update
              $SUDO apt-get install -y nginx
              $SUDO systemctl enable nginx
            fi
            
            # Add rate limiting zones to nginx.conf if not present
            RATELIMIT_OK=false
            if grep -q "zone=general_limit" /etc/nginx/nginx.conf; then
              echo "‚úÖ Rate limiting zones already configured"
              RATELIMIT_OK=true
            else
              echo "üìä Adding rate limiting zones to nginx.conf..."
              # Clean up any broken config first
              $SUDO sed -i '/# Rate limiting zones/d' /etc/nginx/nginx.conf 2>/dev/null || true
              $SUDO sed -i '/limit_req_zone.*zone=api_limit/d' /etc/nginx/nginx.conf 2>/dev/null || true
              $SUDO sed -i '/limit_req_zone.*zone=general_limit/d' /etc/nginx/nginx.conf 2>/dev/null || true
              $SUDO sed -i '/limit_conn_zone.*zone=addr/d' /etc/nginx/nginx.conf 2>/dev/null || true
              # Create temp file with proper nginx config (using printf to avoid whitespace issues)
              printf '%s\n' '    # Rate limiting zones' '    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;' '    limit_req_zone $binary_remote_addr zone=general_limit:10m rate=30r/s;' '    limit_conn_zone $binary_remote_addr zone=addr:10m;' > /tmp/nginx_ratelimit.txt
              # Insert after 'http {' line
              $SUDO sed -i '/http {/r /tmp/nginx_ratelimit.txt' /etc/nginx/nginx.conf
              rm -f /tmp/nginx_ratelimit.txt
              # Verify config
              if $SUDO nginx -t; then
                echo "‚úÖ Rate limiting zones added successfully"
                RATELIMIT_OK=true
              else
                echo "‚ùå ERROR: Failed to add rate limiting zones to nginx.conf"
                echo "‚ùå Nginx config test output:"
                $SUDO nginx -t 2>&1 || true
                echo "‚ùå Cleaning up broken config..."
                $SUDO sed -i '/# Rate limiting zones/d' /etc/nginx/nginx.conf
                $SUDO sed -i '/limit_req_zone.*zone=api_limit/d' /etc/nginx/nginx.conf
                $SUDO sed -i '/limit_req_zone.*zone=general_limit/d' /etc/nginx/nginx.conf
                $SUDO sed -i '/limit_conn_zone.*zone=addr/d' /etc/nginx/nginx.conf
                # Verify cleanup worked
                if ! $SUDO nginx -t; then
                  echo "‚ùå FATAL: Cannot fix nginx.conf - manual intervention required"
                  echo "‚ùå Check /etc/nginx/nginx.conf for syntax errors"
                  exit 1
                fi
                echo "‚ö†Ô∏è Rate limiting disabled - nginx.conf cleaned up"
              fi
            fi
            # Write marker file for site config step
            echo "$RATELIMIT_OK" > /tmp/nginx_ratelimit_ok
            
            # Install Certbot
            if ! command -v certbot &> /dev/null; then
              $SUDO apt-get install -y certbot python3-certbot-nginx
            fi
            
            # Remove any broken configs before certbot
            $SUDO rm -f /etc/nginx/sites-enabled/qubot 2>/dev/null || true
            $SUDO nginx -t 2>/dev/null && $SUDO systemctl reload nginx 2>/dev/null || true
            
            # Get SSL certificate if not exists
            SSL_OBTAINED=false
            if [ -d "/etc/letsencrypt/live/$DOMAIN" ]; then
              SSL_OBTAINED=true
            else
              echo "üîí Obtaining SSL certificate..."
              # Create temporary HTTP config for certbot
              $SUDO tee /etc/nginx/sites-available/qubot > /dev/null << TMPCONF
            server {
                listen 80;
                server_name $DOMAIN;
                location / { return 200 'ok'; }
            }
            TMPCONF
              $SUDO ln -sf /etc/nginx/sites-available/qubot /etc/nginx/sites-enabled/qubot
              if $SUDO nginx -t && $SUDO systemctl reload nginx; then
                if $SUDO certbot certonly --nginx -d $DOMAIN --non-interactive --agree-tos --email admin@$DOMAIN; then
                  SSL_OBTAINED=true
                  echo "‚úÖ SSL certificate obtained"
                else
                  echo "‚ö†Ô∏è SSL failed, will use HTTP only"
                fi
              else
                echo "‚ö†Ô∏è Nginx config test failed"
              fi
            fi
            
            # Check if rate limiting is available from previous step
            RATELIMIT_OK=$(cat /tmp/nginx_ratelimit_ok 2>/dev/null || echo "false")

            # Create final Nginx config (with or without SSL)
            if [ "$SSL_OBTAINED" = true ]; then
              $SUDO tee /etc/nginx/sites-available/qubot > /dev/null << NGINXCONF
            server {
                listen 80;
                server_name $DOMAIN;
                return 301 https://\$host\$request_uri;
            }

            server {
                listen 443 ssl;
                server_name $DOMAIN;

                ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
                include /etc/letsencrypt/options-ssl-nginx.conf;
                ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

                # Security headers
                add_header X-XSS-Protection "1; mode=block" always;
                add_header X-Content-Type-Options "nosniff" always;
                add_header X-Frame-Options "SAMEORIGIN" always;
                add_header Referrer-Policy "strict-origin-when-cross-origin" always;

                # Block bad User-Agents at Nginx level
                if (\$http_user_agent ~* (nmap|nikto|sqlmap|gobuster|dirbuster|masscan|nuclei|l9scan|python-requests|aiohttp)) {
                    return 403;
                }

                # Block empty User-Agent (common in bots/scanners)
                if (\$http_user_agent = "") {
                    return 403;
                }

                # Max request body size
                client_max_body_size 10M;

                # Block sensitive file probes
                location ~* ^/\.(env|git|svn|htaccess|htpasswd|DS_Store) {
                    access_log off;
                    log_not_found off;
                    return 404;
                }

                # Block common attack paths
                location ~* (wp-admin|wp-login|phpMyAdmin|\.php$|cgi-bin) {
                    access_log off;
                    return 404;
                }

                location / {
                    proxy_pass http://127.0.0.1:$BOT_PORT;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                }
            }
            NGINXCONF
              echo "‚úÖ Nginx configured with SSL for bot webhook"
            else
              # HTTP-only fallback config
              $SUDO tee /etc/nginx/sites-available/qubot > /dev/null << NGINXCONF
            server {
                listen 80;
                server_name $DOMAIN;
                location / {
                    proxy_pass http://127.0.0.1:$BOT_PORT;
                    proxy_http_version 1.1;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                }
            }
            NGINXCONF
              echo "‚ö†Ô∏è Nginx configured with HTTP only (SSL failed)"
            fi

            # Add rate limiting to site config only if zones are available
            if [ "$RATELIMIT_OK" = "true" ]; then
              echo "üìä Adding rate limiting to site config..."
              $SUDO sed -i '/# Security headers/a\                # Rate limiting\n                limit_req zone=general_limit burst=50 nodelay;\n                limit_conn addr 30;\n                limit_req_status 429;\n                limit_conn_status 429;\n' /etc/nginx/sites-available/qubot
            else
              echo "‚ö†Ô∏è Skipping rate limiting in site config (zones not available)"
            fi

            $SUDO ln -sf /etc/nginx/sites-available/qubot /etc/nginx/sites-enabled/qubot
            if ! $SUDO nginx -t; then
              echo "‚ùå ERROR: Nginx config test failed for qubot site"
              $SUDO nginx -t 2>&1
              exit 1
            fi
            $SUDO systemctl reload nginx

      - name: Setup Nginx for Web Frontend
        if: steps.check_enabled.outputs.skip != 'true' && (contains(steps.flags.outputs.stdout, 'needs_setup=true') || github.event.inputs.full_setup == 'true')
        uses: appleboy/ssh-action@v1.0.3
        env:
          WEBFRONT_URL: ${{ secrets.WEBFRONT_URL }}
          BOT_PORT: ${{ secrets.BOT_PORT || '6887' }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          envs: WEBFRONT_URL,BOT_PORT
          script: |
            SUDO=""
            if [ "$(id -u)" != "0" ]; then
              SUDO="sudo"
            fi
            
            # Skip if no WEBFRONT_URL
            if [ -z "$WEBFRONT_URL" ]; then
              echo "‚è≠Ô∏è WEBFRONT_URL not set, skipping web frontend Nginx setup"
              exit 0
            fi
            
            # Validate BOT_PORT
            BOT_PORT=${BOT_PORT:-10001}
            if ! [[ "$BOT_PORT" =~ ^[0-9]+$ ]]; then
              echo "‚ùå Invalid BOT_PORT: $BOT_PORT, using default 10001"
              BOT_PORT=10001
            fi
            
            WEB_DOMAIN=$(echo "$WEBFRONT_URL" | sed 's|https://||' | sed 's|/.*||')
            echo "üåê Setting up Nginx for web frontend: $WEB_DOMAIN -> port $BOT_PORT"
            
            # Remove any broken configs before certbot
            $SUDO rm -f /etc/nginx/sites-enabled/qubot-web 2>/dev/null || true
            $SUDO nginx -t 2>/dev/null && $SUDO systemctl reload nginx 2>/dev/null || true
            
            # Get SSL certificate if not exists
            SSL_OBTAINED=false
            if [ -d "/etc/letsencrypt/live/$WEB_DOMAIN" ]; then
              SSL_OBTAINED=true
            else
              echo "üîí Obtaining SSL certificate for $WEB_DOMAIN..."
              # Create temporary HTTP config for certbot
              $SUDO tee /etc/nginx/sites-available/qubot-web > /dev/null << TMPCONF
            server {
                listen 80;
                server_name $WEB_DOMAIN;
                location / { return 200 'ok'; }
            }
            TMPCONF
              $SUDO ln -sf /etc/nginx/sites-available/qubot-web /etc/nginx/sites-enabled/qubot-web
              if $SUDO nginx -t && $SUDO systemctl reload nginx; then
                if $SUDO certbot certonly --nginx -d $WEB_DOMAIN --non-interactive --agree-tos --email admin@$WEB_DOMAIN; then
                  SSL_OBTAINED=true
                  echo "‚úÖ SSL certificate obtained for $WEB_DOMAIN"
                else
                  echo "‚ö†Ô∏è SSL failed for $WEB_DOMAIN, will use HTTP only"
                fi
              else
                echo "‚ö†Ô∏è Nginx config test failed for $WEB_DOMAIN"
              fi
            fi
            
            # Check if rate limiting is available
            RATELIMIT_OK=$(cat /tmp/nginx_ratelimit_ok 2>/dev/null || echo "false")

            # Create final Nginx config (with or without SSL)
            if [ "$SSL_OBTAINED" = true ]; then
              $SUDO tee /etc/nginx/sites-available/qubot-web > /dev/null << NGINXCONF
            server {
                listen 80;
                server_name $WEB_DOMAIN;
                return 301 https://\$host\$request_uri;
            }

            server {
                listen 443 ssl;
                server_name $WEB_DOMAIN;

                ssl_certificate /etc/letsencrypt/live/$WEB_DOMAIN/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/$WEB_DOMAIN/privkey.pem;
                include /etc/letsencrypt/options-ssl-nginx.conf;
                ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

                # Security headers
                add_header X-XSS-Protection "1; mode=block" always;
                add_header X-Content-Type-Options "nosniff" always;
                add_header X-Frame-Options "SAMEORIGIN" always;
                add_header Referrer-Policy "strict-origin-when-cross-origin" always;

                # Block bad User-Agents
                if (\$http_user_agent ~* (nmap|nikto|sqlmap|gobuster|dirbuster|masscan|nuclei|l9scan|python-requests|aiohttp)) {
                    return 403;
                }

                # Block empty User-Agent
                if (\$http_user_agent = "") {
                    return 403;
                }

                # Max request body size
                client_max_body_size 10M;

                # Block sensitive file probes
                location ~* ^/\.(env|git|svn|htaccess|htpasswd|DS_Store) {
                    access_log off;
                    log_not_found off;
                    return 404;
                }

                # Block common attack paths
                location ~* (wp-admin|wp-login|phpMyAdmin|\.php$|cgi-bin) {
                    access_log off;
                    return 404;
                }

                location / {
                    proxy_pass http://127.0.0.1:$BOT_PORT;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                }

                # WebSocket support for /ws paths
                location /ws {
                    proxy_pass http://127.0.0.1:$BOT_PORT;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_set_header Host \$host;
                    proxy_read_timeout 86400;
                }
            }
            NGINXCONF
              echo "‚úÖ Nginx configured with SSL for web frontend: https://$WEB_DOMAIN"
            else
              # HTTP-only fallback config
              $SUDO tee /etc/nginx/sites-available/qubot-web > /dev/null << NGINXCONF
            server {
                listen 80;
                server_name $WEB_DOMAIN;
                location / {
                    proxy_pass http://127.0.0.1:$BOT_PORT;
                    proxy_http_version 1.1;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                }
                location /ws {
                    proxy_pass http://127.0.0.1:$BOT_PORT;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_read_timeout 86400;
                }
            }
            NGINXCONF
              echo "‚ö†Ô∏è Nginx configured with HTTP only for web frontend (SSL failed)"
            fi

            # Add rate limiting to site config only if zones are available
            if [ "$RATELIMIT_OK" = "true" ]; then
              echo "üìä Adding rate limiting to web frontend config..."
              $SUDO sed -i '/# Security headers/a\                # Rate limiting\n                limit_req zone=general_limit burst=50 nodelay;\n                limit_conn addr 30;\n                limit_req_status 429;\n                limit_conn_status 429;\n' /etc/nginx/sites-available/qubot-web
            else
              echo "‚ö†Ô∏è Skipping rate limiting in web frontend config (zones not available)"
            fi

            $SUDO ln -sf /etc/nginx/sites-available/qubot-web /etc/nginx/sites-enabled/qubot-web
            if ! $SUDO nginx -t; then
              echo "‚ùå ERROR: Nginx config test failed for qubot-web site"
              $SUDO nginx -t 2>&1
              exit 1
            fi
            $SUDO systemctl reload nginx

      - name: Deploy to VPS via SSH
        if: steps.check_enabled.outputs.skip != 'true'
        uses: appleboy/ssh-action@v1.0.3
        env:
          DEPLOY_BRANCH: ${{ env.DEPLOY_BRANCH }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          envs: DEPLOY_BRANCH
          script: |
            SUDO=""
            if [ "$(id -u)" != "0" ]; then
              SUDO="sudo"
            fi

            cd /opt/qubot || {
              $SUDO mkdir -p /opt/qubot || { echo "‚ùå Failed to create /opt/qubot"; exit 1; }
              $SUDO chown -R "$USER:$USER" /opt/qubot || true
              cd /opt/qubot || { echo "‚ùå Failed to cd into /opt/qubot"; exit 1; }
              git clone https://github.com/${{ github.repository }}.git .
            }
            
            git fetch origin "$DEPLOY_BRANCH"
            git checkout -B "$DEPLOY_BRANCH" "origin/$DEPLOY_BRANCH"
            git reset --hard "origin/$DEPLOY_BRANCH"
            
            # Export sensitive secrets as environment variables (NOT written to disk)
            export TG_SESSIONS_JSON='${{ secrets.TG_SESSIONS_JSON }}'
            export RSS_BOT_TOKEN='${{ secrets.RSS_BOT_TOKEN }}'
            export AI_BOT_TOKEN='${{ secrets.AI_BOT_TOKEN }}'
            export AGENT_BOT_TOKEN='${{ secrets.AGENT_BOT_TOKEN }}'
            export MONITOR_BOT_TOKEN='${{ secrets.MONITOR_BOT_TOKEN }}'
            export WEBHOOK_URL='${{ secrets.WEBHOOK_URL }}'
            export BOT_PORT='${{ secrets.BOT_PORT }}'
            export BOT_SECRET='${{ secrets.BOT_SECRET }}'
            export GROQ_API_KEY='${{ secrets.GROQ_API_KEY }}'
            export GEMINI_API_KEY='${{ secrets.GEMINI_API_KEY }}'
            export OPENAI_API_KEY='${{ secrets.OPENAI_API_KEY }}'
            export CLAUDE_API_KEY='${{ secrets.CLAUDE_API_KEY }}'
            export NVIDIA_API_KEY='${{ secrets.NVIDIA_API_KEY }}'
            export GLM_API_KEY='${{ secrets.GLM_API_KEY }}'
            export MINIMAX_API_KEY='${{ secrets.MINIMAX_API_KEY }}'
            export OPENROUTER_API_KEY='${{ secrets.OPENROUTER_API_KEY }}'
            export API_KEYS='${{ secrets.API_KEYS }}'
            export CRAWLER_BOT_TOKEN='${{ secrets.CRAWLER_BOT_TOKEN }}'
            export FILE_BOT_TOKEN='${{ secrets.FILE_BOT_TOKEN }}'
            export VIBE_BOT_TOKEN='${{ secrets.VIBE_BOT_TOKEN }}'
            export BOT_GITHUB_TOKEN='${{ secrets.BOT_GITHUB_TOKEN }}'
            export FILE_TARGET_GROUP='${{ secrets.FILE_TARGET_GROUP }}'
            export DATA_PROXY='${{secrets.DATA_PROXY }}'
            
            # Create .env file for NON-SENSITIVE config only (with restrictive permissions)
            cat > .env << 'EOF'
            # Non-sensitive configuration (secrets are passed via environment variables)
            EOF
            chmod 600 .env
            
            # Add non-sensitive config to .env
            printf 'SOURCE_CHANNELS=%s\n' '${{ secrets.SOURCE_CHANNELS }}' >> .env
            printf 'TARGET_GROUP=%s\n' '${{ secrets.TARGET_GROUP }}' >> .env
            printf 'TARGET_CHANNEL=%s\n' '${{ secrets.TARGET_CHANNEL }}' >> .env
            printf 'VIP_TARGET_CHANNEL=%s\n' '${{ secrets.VIP_TARGET_CHANNEL }}' >> .env
            printf 'REPORT_TARGET_GROUP=%s\n' '${{ secrets.REPORT_TARGET_GROUP }}' >> .env
            printf 'REPORT_TARGET_CHANNEL=%s\n' '${{ secrets.REPORT_TARGET_CHANNEL }}' >> .env
            printf 'DABAN_GROUP=%s\n' '${{ secrets.DABAN_GROUP }}' >> .env
            printf 'DABAN_CHANNEL=%s\n' '${{ secrets.DABAN_CHANNEL }}' >> .env
            printf 'LIMITUP_TARGET_GROUP=%s\n' '${{ secrets.LIMITUP_TARGET_GROUP }}' >> .env
            printf 'BURST_TARGET_GROUP=%s\n' '${{ secrets.BURST_TARGET_GROUP }}' >> .env
            printf 'KEYWORDS=%s\n' '${{ secrets.KEYWORDS }}' >> .env
            printf 'FROM_USERS=%s\n' '${{ secrets.FROM_USERS }}' >> .env
            printf 'ALLOWED_USERS=%s\n' '${{ secrets.ALLOWED_USERS }}' >> .env
            printf 'NOTES_REPO=%s\n' '${{ secrets.NOTES_REPO }}' >> .env
            printf 'GIT_SSH_KEY_PATH=%s\n' '${{ secrets.GIT_SSH_KEY_PATH }}' >> .env
            printf 'GIT_SSH_COMMAND=%s\n' '${{ secrets.GIT_SSH_COMMAND }}' >> .env
            printf 'API_ENABLED=%s\n' '${{ secrets.API_ENABLED }}' >> .env
            printf 'WEBFRONT_URL=%s\n' '${{ secrets.WEBFRONT_URL }}' >> .env
            printf 'CRAWLER_BOT_USERNAME=%s\n' '${{ secrets.CRAWLER_BOT_USERNAME }}' >> .env
            printf 'RATE_LIMIT_MS=%s\n' '${{ secrets.RATE_LIMIT_MS }}' >> .env
            printf 'LOG_LEVEL=%s\n' '${{ secrets.LOG_LEVEL }}' >> .env
            printf 'TWITTER_ACCOUNTS=%s\n' '${{ secrets.TWITTER_ACCOUNTS }}' >> .env
            printf 'TWITTER_AUTH_TOKEN=%s\n' '${{ secrets.TWITTER_AUTH_TOKEN }}' >> .env
            printf 'TWITTER_CT0=%s\n' '${{ secrets.TWITTER_CT0 }}' >> .env
            printf 'BLACKLIST_CHANNELS=%s\n' '${{ secrets.BLACKLIST_CHANNELS }}' >> .env
            printf 'STOCK_ALERT_CHANNEL=%s\n' '${{ secrets.STOCK_ALERT_CHANNEL }}' >> .env
            printf 'ALERT_CHANNEL=%s\n' '${{ secrets.ALERT_CHANNEL }}' >> .env
            printf 'FILE_TARGET_GROUP=%s\n' '${{ secrets.FILE_TARGET_GROUP }}' >> .env
            printf 'DATA_PROXY=%s\n' '${{ secrets.DATA_PROXY }}' >> .env
            
            # Deploy with smart rebuild logic
            docker compose down || true
            
            # Check if deps changed (Dockerfile, requirements.txt, docker-compose.yml)
            NEEDS_REBUILD=false
            FORCE_REBUILD="${{ github.event.inputs.force_rebuild }}"
            
            if [ "$FORCE_REBUILD" = "true" ]; then
              echo "üîÑ Force rebuild requested"
              NEEDS_REBUILD=true
            elif [ ! -f .deps_hash ]; then
              echo "üÜï First build, creating deps hash"
              NEEDS_REBUILD=true
            elif ! sha256sum -c .deps_hash --quiet 2>/dev/null; then
              echo "üì¶ Dependencies changed, rebuilding"
              NEEDS_REBUILD=true
            else
              echo "‚ö° No dependency changes, using cache"
            fi
            
            # Build with or without cache
            if [ "$NEEDS_REBUILD" = "true" ]; then
              docker compose build --no-cache || { echo "‚ùå Build failed!"; exit 1; }
            else
              docker compose build || { echo "‚ùå Build failed!"; exit 1; }
            fi
            
            # Update deps hash
            sha256sum Dockerfile requirements.txt docker-compose.yml > .deps_hash 2>/dev/null || true
            
            docker compose up -d

            # ARM py_mini_racer fix: symlink armlibmini_racer.glibc.so -> libmini_racer.glibc.so
            if docker compose ps userbot &> /dev/null; then
              docker compose exec -T userbot sh -lc '
              set -e
              cd /usr/local/lib/python3.11/site-packages/py_mini_racer
              if [ -f armlibmini_racer.glibc.so ] && [ ! -e libmini_racer.glibc.so ]; then
                ln -s armlibmini_racer.glibc.so libmini_racer.glibc.so
                echo "‚úÖ py_mini_racer ARM symlink created"
              else
                echo "‚ÑπÔ∏è py_mini_racer ARM symlink not needed"
              fi
              ' || true
            fi
            
            # Wait for userbot to be healthy
            echo "‚è≥ Waiting for services to be healthy..."
            timeout 60 bash -c 'until docker compose ps userbot | grep -q "(healthy)"; do sleep 2; done' || {
              echo "‚ö†Ô∏è Timeout waiting for health, checking status..."
            }
            
            docker compose ps
            
            # Verify container is running
            if ! docker compose ps userbot | grep -q "Up"; then
              echo "‚ùå Userbot failed to start"
              docker compose logs userbot
              exit 1
            fi
            
            # Mark as deployed (for incremental deploy detection)
            touch .deployed
            
            echo "‚úÖ Deployment successful!"

      - name: Register Webhooks
        if: steps.check_enabled.outputs.skip != 'true'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            cd /opt/qubot
            
            # Skip if no WEBHOOK_URL
            if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then
              echo "‚è≠Ô∏è No WEBHOOK_URL, using polling mode"
              exit 0
            fi
            
            if docker compose ps userbot | grep -q "Up"; then
              docker compose exec -T userbot python scripts/setup_webhook.py
            else
              echo "‚ùå Container not running"
              exit 1
            fi
